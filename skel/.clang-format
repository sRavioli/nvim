---
# Language, this format style is targeted at.
#
# Possible values:
#
# - `LK_None` (in configuration: `None`) Do not use.
# - `LK_Cpp` (in configuration: `Cpp`) Should be used for C, C++.
# - `LK_CSharp` (in configuration: `CSharp`) Should be used for C#.
# - `LK_Java` (in configuration: `Java`) Should be used for Java.
# - `LK_JavaScript` (in configuration: `JavaScript`) Should be used for
#   JavaScript.
# - `LK_Json` (in configuration: `Json`) Should be used for JSON.
# - `LK_ObjC` (in configuration: `ObjC`) Should be used for Objective-C,
#   Objective-C++.
# - `LK_Proto` (in configuration: `Proto`) Should be used for Protocol Buffers.
# - `LK_TableGen` (in configuration: `TableGen`) Should be used for TableGen
#   code.
# - `LK_TextProto` (in configuration: `TextProto`) Should be used for Protocol
#   Buffer messages in text format.
# - `LK_Verilog` (in configuration: `Verilog`) Should be used for Verilog and
#   SystemVerilog.
#
# (LanguageKind)
Language: Cpp

# The style used for all options not specifically set in the configuration.
#
# This option is supported only in the **clang-format** configuration (both
# within `-style='{...}'` and the `.clang-format` file).
#
# Possible values:
#
# - `LLVM` A style complying with the LLVM coding standards
# - `Google` A style complying with Google’s C++ style guide
# - `Chromium` A style complying with Chromium’s style guide
# - `Mozilla` A style complying with Mozilla’s style guide
# - `WebKit` A style complying with WebKit’s style guide
# - `Microsoft` A style complying with Microsoft’s style guide
# - `GNU` A style complying with the GNU coding standards
# - `InheritParentConfig` Not a real style, but allows to use the
#   `.clang-format` file from the parent directory (or its parent if there is
#   none). If there is no parent file found it falls back to the `fallback`
#   style, and applies the changes to that.
#
#   With this option you can overwrite some parts of your main style for your
#   subdirectories. This is also possible through the command line, e.g.:
#   `--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}`
#
# (string)
# BasedOnStyle: Google

# The extra indent or outdent of access modifiers, e.g. `public:`.
#
# (integer)
AccessModifierOffset: -1

# If `true`, horizontally aligns arguments after an open bracket.
#
# This applies to round brackets (parentheses), angle brackets and square
# brackets.
#
# Possible values:
#
# - `BAS_Align` (in configuration: `Align`) Align parameters on the open
#   bracket.
# - `BAS_DontAlign` (in configuration: `DontAlign`) Don’t align, instead use
#   `ContinuationIndentWidth`.
# - `BAS_AlwaysBreak` (in configuration: `AlwaysBreak`) Always break after an
#   open bracket, if the parameters don’t fit on a single line.
# - `BAS_BlockIndent` (in configuration: `BlockIndent`) Always break after an
#   open bracket, if the parameters don’t fit on a single line. Closing brackets
#   will be placed on a new line.
#
# NOTE:
# This currently only applies to braced initializer lists (when
# `Cpp11BracedListStyle` is `true`) and parentheses.
#
# (BracketAlignmentStyle)
AlignAfterOpenBracket: Align

# if not `None`, when using initialization for an array of structs aligns the
# fields into columns.
#
# NOTE: As of clang-format 15 this option only applied to arrays with equal
#       number of columns per row.
#
# Possible values:
#
# - `AIAS_Left` (in configuration: `Left`) Align array column and left justify
#   the columns.
# - `AIAS_Right` (in configuration: `Right`) Align array column and right
#   justify the columns.
# - `AIAS_None` (in configuration: `None`) Don’t align array initializer
#   columns.
#
# (ArrayInitializerAlignmentStyle)
AlignArrayOfStructures: Right

# Style of aligning consecutive assignments.
#
# `Consecutive` will result in formatting like:
#
# ```cpp
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# ```
#
# Nested configuration flags:
#
# Alignment options.
#
# They can also be read as a whole for compatibility. The choices are:
#
# - None
# - Consecutive
# - AcrossEmptyLines
# - AcrossComments
# - AcrossEmptyLinesAndComments
#
# For example, to align across empty lines and not across comments, either of
# these work.
#
# ```yaml
# AlignConsecutiveMacros: AcrossEmptyLines
#
# AlignConsecutiveMacros:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: false
# ```
#
# (AlignConsecutiveStyle)
AlignConsecutiveAssignments:
  # Whether aligning is enabled.
  #
  # (boolean)
  Enabled: false

  # Whether to align across empty lines.
  #
  # (boolean)
  AcrossEmptyLines: false

  # Whether to align across comments.
  #
  # (boolean)
  AcrossComments: false

  # Only for `AlignConsecutiveAssignments`. Whether compound assignments like
  # `+=` are aligned along with `=`.
  #
  # (boolean)
  AlignCompound: false

  # Only for `AlignConsecutiveAssignments`. Whether short assignment operators
  # are left-padded to the same length as long ones in order to put all
  # assignment operators to the right of the left hand side.
  #
  # (boolean)
  PadOperators: true

# Style of aligning consecutive bit fields.
#
# `Consecutive` will align the bitfield separators of consecutive lines. This
# will result in formatting like:
#
# ```cpp
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
# ```
#
# Nested configuration flags:
#
# Alignment options.
#
# They can also be read as a whole for compatibility. The choices are:
#
# - None
# - Consecutive
# - AcrossEmptyLines
# - AcrossComments
# - AcrossEmptyLinesAndComments
#
# For example, to align across empty lines and not across comments, either of
# these work.
#
# ```yaml
# AlignConsecutiveMacros: AcrossEmptyLines
#
# AlignConsecutiveMacros:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: false
# ```
#
# (AlignConsecutiveStyle)
AlignConsecutiveBitFields:
  # Whether aligning is enabled.
  #
  # (boolean)
  Enabled: false

  # Whether to align across empty lines.
  #
  # (boolean)
  AcrossEmptyLines: false

  # Whether to align across comments.
  #
  # (boolean)
  AcrossComments: false

  # Only for `AlignConsecutiveAssignments`. Whether compound assignments like
  # `+=` are aligned along with `=`.
  #
  # (boolean)
  AlignCompound: false

  # Only for `AlignConsecutiveAssignments`. Whether short assignment operators
  # are left-padded to the same length as long ones in order to put all
  # assignment operators to the right of the left hand side.
  #
  # (boolean)
  PadOperators: false

# Style of aligning consecutive declarations.
#
# `Consecutive` will align the declaration names of consecutive lines. This will
# result in formatting like:
#
# ```cpp
# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
#
# ```
#
# Nested configuration flags:
#
# Alignment options.
#
# They can also be read as a whole for compatibility. The choices are:
#
# - None
# - Consecutive
# - AcrossEmptyLines
# - AcrossComments
# - AcrossEmptyLinesAndComments
#
# For example, to align across empty lines and not across comments, either of
# these work.
#
# ```yaml
# AlignConsecutiveMacros: AcrossEmptyLines
#
# AlignConsecutiveMacros:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: false
# ```
#
# (AlignConsecutiveStyle)
AlignConsecutiveDeclarations:
  # Whether aligning is enabled.
  #
  # (boolean)
  Enabled: false

  # Whether to align across empty lines.
  #
  # (boolean)
  AcrossEmptyLines: false

  # Whether to align across comments.
  #
  # (boolean)
  AcrossComments: false

  # Only for `AlignConsecutiveAssignments`. Whether compound assignments like
  # `+=` are aligned along with `=`.
  #
  # (boolean)
  AlignCompound: false

  # Only for `AlignConsecutiveAssignments`. Whether short assignment operators
  # are left-padded to the same length as long ones in order to put all
  # assignment operators to the right of the left hand side.
  #
  # (boolean)
  PadOperators: false

# Style of aligning consecutive macro definitions.
#
# `Consecutive` will result in formatting like:
#
# ```cpp
# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x - x)
# #define bar(y, z)        (y + z)
# ```
#
# Nested configuration flags:
#
# Alignment options.
#
# They can also be read as a whole for compatibility. The choices are:
#
# - None
# - Consecutive
# - AcrossEmptyLines
# - AcrossComments
# - AcrossEmptyLinesAndComments
#
# For example, to align across empty lines and not across comments, either of
# these work.
#
# ```yaml
# AlignConsecutiveMacros: AcrossEmptyLines
#
# AlignConsecutiveMacros:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: false
# ```
#
# (AlignConsecutiveStyle)
AlignConsecutiveMacros:
  # Whether aligning is enabled.
  #
  # (boolean)
  Enabled: false

  # Whether to align across empty lines.
  #
  # (boolean)
  AcrossEmptyLines: false

  # Whether to align across comments.
  #
  # (boolean)
  AcrossComments: false

  # Only for `AlignConsecutiveAssignments`. Whether compound assignments like
  # `+=` are aligned along with `=`.
  #
  # (boolean)
  AlignCompound: false

  # Only for `AlignConsecutiveAssignments`. Whether short assignment operators
  # are left-padded to the same length as long ones in order to put all
  # assignment operators to the right of the left hand side.
  #
  # (boolean)
  PadOperators: false

# Style of aligning consecutive short case labels. Only applies if
# `AllowShortCaseLabelsOnASingleLine` is `true`.
#
# ```yaml
# # Example of usage:
# AlignConsecutiveShortCaseStatements:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: true
#   AlignCaseColons: false
# ```
#
# (AlignConsecutiveStyle)
AlignConsecutiveShortCaseStatements:
  # Whether aligning is enabled.
  #
  # (boolean)
  Enabled: false

  # Whether to align across empty lines.
  #
  # (boolean)
  AcrossEmptyLines: false

  # Whether to align across comments.
  #
  # (boolean)
  AcrossComments: false

  # Whether aligned case labels are aligned on the colon, or on the , or on the
  # tokens after the colon.
  #
  # (boolean)
  AlignCaseColons: false

# Options for aligning backslashes in escaped newlines.
#
# Possible values:
#
# - `ENAS_DontAlign` (in configuration: `DontAlign`) Don’t align escaped
#   newlines.
# - `ENAS_Left` (in configuration: `Left`) Align escaped newlines as far left as
#   possible.
# - `ENAS_Right` (in configuration: `Right`) Align escaped newlines in the
#   right-most column.
#
# (EscapedNewlineAlignmentStyle)
AlignEscapedNewlines: Left

# If `true`, horizontally align operands of binary and ternary expressions.
#
# Possible values:
#
# - `OAS_DontAlign` (in configuration: `DontAlign`) Do not align operands of
#   binary and ternary expressions. The wrapped lines are indented
#   `ContinuationIndentWidth` spaces from the start of the line.
# - `OAS_Align` (in configuration: `Align`) Horizontally align operands of
#   binary and ternary expressions.
#
#   Specifically, this aligns operands of a single expression that needs to be
#   split over multiple lines.
#
#   When `BreakBeforeBinaryOperators` is set, the wrapped operator is aligned
#   with the operand on the first line.
# - `OAS_AlignAfterOperator` (in configuration: `AlignAfterOperator`)
#   Horizontally align operands of binary and ternary expressions.
#
#   This is similar to `AO_Align`, except when `BreakBeforeBinaryOperators` is
#   set, the operator is un-indented so that the wrapped operand is aligned with
#   the operand on the first line.
#
# (OperandAlignmentStyle)
AlignOperands: Align

# Control of trailing comments.
#
# The alignment stops at closing braces after a line break, and only followed by
# other closing braces, a (`do-`) `while`, a lambda call, or a semicolon.
#
# NOTE: As of clang-format 16 this option is not a boolean but can be set to the
#       options. Conventional boolean options still can be parsed as before.
#
# (TrailingCommentsAlignmentStyle)
AlignTrailingComments:
  # Specifies the way to align trailing comments.
  #
  # Possible values:
  #
  # - `TCAS_Leave` (in configuration: `Leave`) Leave trailing comments as they
  #   are.
  # - `TCAS_Always` (in configuration: `Always`) Align trailing comments.
  # - `TCAS_Never` (in configuration: `Never`) Don’t align trailing comments but
  #   other formatter applies.
  #
  # (TrailingCommentsAlignmentKinds )
  Kind: Always

  # How many empty lines to apply alignment. When both `MaxEmptyLinesToKeep` and
  # `OverEmptyLines` are set to 2, it formats like below.
  #
  # ```cpp
  #  int a;      // all these
  #
  #  int ab;     // comments are
  #
  #
  #  int abcdef; // aligned
  #  ```
  #
  # When `MaxEmptyLinesToKeep` is set to 2 and `OverEmptyLines` is set to 1, it
  # formats like below.
  #
  # ```cpp
  # int a;  // these are
  #
  # int ab; // aligned
  #
  #
  # int abcdef; // but this isn't
  # ```
  #
  # (unsigned)
  OverEmptyLines: 0

# If a function call or braced initializer list doesn’t fit on a line, allow
# putting all arguments onto the next line, even if `BinPackArguments` is false.
#
# (boolean)
AllowAllArgumentsOnNextLine: true

# If the function declaration doesn’t fit on a line, allow putting all
# parameters of a function declaration onto the next line even if
# `BinPackParameters` is false.
#
# (boolean)
AllowAllParametersOfDeclarationOnNextLine: true

# Dependent on the value, `while (true) { continue; }` can be put on a single
# line.
#
# Possible values:
#
# - `SBS_Never` (in configuration: `Never`) Never merge blocks into a single
#   line.
# - `SBS_Empty` (in configuration: `Empty`) Only merge empty blocks.
# - `SBS_Always` (in configuration: `Always`) Always merge short blocks into a
#   single line.
#
# (ShortBlockStyle)
AllowShortBlocksOnASingleLine: Never

# If `true`, short case labels will be contracted to a single line.
#
# (boolean)
AllowShortCaseLabelsOnASingleLine: false

# Allow short enums on a single line.
#
# (boolean)
AllowShortEnumsOnASingleLine: true

# Dependent on the value, `int f() { return 0; }` can be put on a single line.
#
# Possible values:
#
# - `SFS_None` (in configuration: `None`) Never merge functions into a single
#   line.
# - `SFS_InlineOnly` (in configuration: `InlineOnly`) Only merge functions
#   defined inside a class. Same as “inline”, except it does not implies
#   "empty": i.e. top level empty functions are not merged either.
# - `SFS_Empty` (in configuration: `Empty`) Only merge empty functions.
# - `SFS_Inline` (in configuration: `Inline`) Only merge functions defined
#   inside a class. Implies “empty”.
# - `SFS_All` (in configuration: `All`) Merge all functions fitting on a single
#   line.
#
# (ShortFunctionStyle)
AllowShortFunctionsOnASingleLine: All

# Dependent on the value, `if (a) return;` can be put on a single line.
#
# Possible values:
#
# - `SIS_Never` (in configuration: `Never`) Never put short ifs on the same
#   line.
# - `SIS_WithoutElse` (in configuration: `WithoutElse`) Put short ifs on the
#   same line only if there is no else statement.
# - `SIS_OnlyFirstIf` (in configuration: `OnlyFirstIf`) Put short ifs, but not
#   else ifs nor else statements, on the same line.
# - `SIS_AllIfsAndElse` (in configuration: `AllIfsAndElse`) Always put short
#   ifs, else ifs and else statements on the same line.
#
# (ShortIfStyle)
AllowShortIfStatementsOnASingleLine: WithoutElse

# Dependent on the value, `auto lambda []() { return 0; }` can be put on a
# single line.
#
# Possible values:
#
# - `SLS_None` (in configuration: `None`) Never merge lambdas into a single
#   line.
# - `SLS_Empty` (in configuration: `Empty`) Only merge empty lambdas.
# - `SLS_Inline` (in configuration: `Inline`) Merge lambda into a single line if
#   the lambda is argument of a function.
# - `SLS_All` (in configuration: `All`) Merge all lambdas fitting on a single
#   line.
#
# (ShortLambdaStyle)
AllowShortLambdasOnASingleLine: All

# If true, while (true) continue; can be put on a single line.
#
# (boolean)
AllowShortLoopsOnASingleLine: true

# The function definition return type breaking style to use. This option is
# **deprecated** and is retained for backwards compatibility.
#
# Possible values:
#
# - `DRTBS_None` (in configuration: `None`) Break after return type
#   automatically. `PenaltyReturnTypeOnItsOwnLine` is taken into account.
# - `DRTBS_All` (in configuration: `All`) Always break after the return type.
# - `DRTBS_TopLevel` (in configuration: `TopLevel`) Always break after the
#   return types of top-level functions.
#
# (DefinitionReturnTypeBreakingStyle)
AlwaysBreakAfterDefinitionReturnType: None

# The function declaration return type breaking style to use.
#
# Possible values:
#
# - `RTBS_None` (in configuration: `None`) Break after return type
#   automatically. `PenaltyReturnTypeOnItsOwnLine` is taken into account.
# - `RTBS_All` (in configuration: `All`) Always break after the return type.
# - `RTBS_TopLevel` (in configuration: `TopLevel`) Always break after the return
#   types of top-level functions.
# - `RTBS_AllDefinitions` (in configuration: `AllDefinitions`) Always break
#   after the return type of function definitions.
# - `RTBS_TopLevelDefinitions` (in configuration: `TopLevelDefinitions`) Always
#   break after the return type of top-level definitions.
#
# (ReturnTypeBreakingStyle)
AlwaysBreakAfterReturnType: None

# If `true`, always break before multiline string literals.
#
# This flag is mean to make cases where there are multiple multiline strings in
# a file look more consistent. Thus, it will only take effect if wrapping the
# string at that point leads to it being indented `ContinuationIndentWidth`
# spaces from the start of the line.
#
# (boolean)
AlwaysBreakBeforeMultilineStrings: true

# The template declaration breaking style to use.
#
# Possible values:
#
# - `BTDS_No` (in configuration: `No`) Do not force break before declaration.
#   `PenaltyBreakTemplateDeclaration` is taken into account.
# - `BTDS_MultiLine` (in configuration: `MultiLine`) Force break after template
#   declaration only when the following declaration spans multiple lines.
# - `BTDS_Yes` (in configuration: `Yes`) Always break after template
#   declaration.
#
# (BreakTemplateDeclarationsStyle)
AlwaysBreakTemplateDeclarations: true

# A vector of strings that should be interpreted as attributes/qualifiers
# instead of identifiers. This can be useful for language extensions or static
# analyzer annotations.
#
# (List of Strings)
AttributeMacros: [__capability]

# If `false`, a function call’s arguments will either be all on the same line or
# will have one line each.
#
# (boolean)
BinPackArguments: true

# If `false`, a function declaration’s or function definition’s parameters will
# either all be on the same line or will have one line each.
#
# (boolean)
BinPackParameters: true

# The BitFieldColonSpacingStyle to use for bitfields.
#
# Possible values:
#
# - `BFCS_Both` (in configuration: `Both`) Add one space on each side of the `:`
# - `BFCS_None` (in configuration: `None`) Add no space around the `:` (except
#   when needed for `AlignConsecutiveBitFields`).
# - `BFCS_Before` (in configuration: `Before`) Add space before the `:` only
# - `BFCS_After` (in configuration: `After`) Add space after the `:` only (space
#   may be added before if needed for `AlignConsecutiveBitFields`).
#
# (BitFieldColonSpacingStyle)
BitFieldColonSpacing: Both

# Control of individual brace wrapping cases.
#
# If `BreakBeforeBraces` is set to `BS_Custom`, use this to specify how each
# individual brace case should be handled. Otherwise, this is ignored.
#
# (BraceWrappingFlags)
BraceWrapping:
  # Wrap case labels.
  #
  # (boolean)
  AfterCaseLabel: false

  # Wrap class definitions
  #
  # (boolean)
  AfterClass: false

  # Wrap control statements (`if`/`for`/`while`/`switch`/..).
  #
  # Possible values:
  #
  # - `BWACS_Never` (in configuration: `Never`) Never wrap braces after a
  #   control statement.
  # - `BWACS_MultiLine` (in configuration: `MultiLine`) Only wrap braces after
  #   a multi-line control statement.
  # - `BWACS_Always` (in configuration: `Always`) Always wrap braces after a
  #   control statement.
  #
  # (BraceWrappingAfterControlStatementStyle)
  AfterControlStatement: Never

  # Wrap enum definitions.
  #
  # (boolean)
  AfterEnum: false

  # Wrap extern blocks.
  #
  # (boolean)
  AfterExternBlock: false

  # Wrap function definitions.
  #
  # (boolean)
  AfterFunction: false

  # Wrap namespace definitions.
  #
  # (boolean)
  AfterNamespace: false

  # Wrap ObjC definitions (interfaces, implementations…).
  #
  # NOTE: @autoreleasepool and @synchronized blocks are wrapped according to
  #       `AfterControlStatement` flag.
  #
  # (boolean)
  AfterObjCDeclaration: false

  # Wrap struct definitions.
  #
  # (boolean)
  AfterStruct: false

  # Wrap union definitions.
  #
  # (boolean)
  AfterUnion: false

  # Wrap before `catch`.
  #
  # (boolean)
  BeforeCatch: false

  # Wrap before `else`.
  #
  # (boolean)
  BeforeElse: false

  # Wrap lambda block.
  #
  # (boolean)
  BeforeLambdaBody: false

  # Wrap before `while`.
  #
  # (boolean)
  BeforeWhile: false

  # Indent the wrapped braces themselves.
  #
  # (boolean)
  IndentBraces: false

  # If `false`, empty function body can be put on a single line. This option is
  # used only if the opening brace of the function has already been wrapped,
  # i.e. the `AfterFunction` brace wrapping mode is set, and the function
  # could/should not be put on a single line (as per
  # `AllowShortFunctionsOnASingleLine` and constructor formatting options).
  #
  # (boolean)
  SplitEmptyFunction: true

  # If `false`, empty record (e.g. class, struct or union) body can be put on a
  # single line. This option is used only if the opening brace of the record has
  # already been wrapped, i.e. the `AfterClass` (for classes) brace wrapping
  # mode is set.
  #
  # (boolean)
  SplitEmptyRecord: true

  # If `false`, empty namespace body can be put on a single line. This option is
  # used only if the opening brace of the namespace has already been wrapped,
  # i.e. the `AfterNamespace` brace wrapping mode is set.
  SplitEmptyNamespace: true

# Break after a group of C++11 attributes before variable or function (including
# constructor/destructor) declaration/definition names or before control
# statements, i.e. `if`, `switch` (including `case` and `default` labels), `for`
# , and `while` statements.
#
# Possible values:
#
# - `ABS_Always` (in configuration: `Always`) Always break after attributes.
# - `ABS_Leave` (in configuration: `Leave`) Leave the line breaking after
#   attributes as is.
# - `ABS_Never` (in configuration: `Never`) Never break after attributes.
#
# (AttributeBreakingStyle)
BreakAfterAttributes: Never

# Break after each annotation on a field in Java files.
#
# (boolean)
BreakAfterJavaFieldAnnotations: false

# If `true`, clang-format will always break after a Json array `[` otherwise it
# will scan until the closing `]` to determine if it should add newlines between
# elements (prettier compatible).
#
# NOTE: This is currently only for formatting JSON.
#
# (boolean)
BreakArrays: true

# The way to wrap binary operators.
#
# Possible values:
#
# - `BOS_None` (in configuration: `None`) Break after operators.
# - `BOS_NonAssignment` (in configuration: `NonAssignment`) Break before
#   operators that aren’t assignments.
# - `BOS_All` (in configuration: `All`) Break before operators.
#
# (BinaryOperatorStyle)
BreakBeforeBinaryOperators: None

# The concept declaration style to use.
#
# Possible values:
#
# - `BBCDS_Never` (in configuration: `Never`) Keep the template declaration line
#   together with `concept`.
# - `BBCDS_Allowed` (in configuration: `Allowed`) Breaking between template
#   declaration and `concept` is allowed. The actual behavior depends on the
#   content and line breaking rules and penalties.
# - `BBCDS_Always` (in configuration: `Always`) Always break before `concept`,
#   putting it in the line after the template declaration.
#
# (BreakBeforeConceptDeclarationsStyle)
BreakBeforeConceptDeclarations: Always

# The brace breaking style to use.
#
# Possible values:
#
# - `BS_Attach` (in configuration: `Attach`) Always attach braces to surrounding
#   context.
# - `BS_Linux` (in configuration: `Linux`) Like `Attach`, but break before
#   braces on function, namespace and class definitions.
# - `BS_Mozilla` (in configuration: `Mozilla`) Like `Attach`, but break before
#   braces on enum, function, and record definitions.
# - `BS_Stroustrup` (in configuration: `Stroustrup`) Like `Attach`, but break
#   before function definitions, `catch`, and `else`.
# - `BS_Allman` (in configuration: `Allman`) Always break before braces.
# - `BS_Whitesmiths` (in configuration: `Whitesmiths`) Like `Allman` but always
#   indent braces and line up code with braces.
# - `BS_GNU` (in configuration: `GNU`) Always break before braces and add an
#   extra level of indentation to braces of control statements, not to those of
#   class, function or other definitions.
# - `BS_WebKit` (in configuration: `WebKit`) Like `Attach`, but break before
#   functions.
# - `BS_Custom` (in configuration: `Custom`) Configure each individual brace in
#   `BraceWrapping`.
#
# (BraceBreakingStyle)
BreakBeforeBraces: Attach

# The inline ASM colon style to use.
#
# Possible values:
#
# - `BBIAS_Never` (in configuration: `Never`) No break before inline ASM colon.
# - `BBIAS_OnlyMultiline` (in configuration: `OnlyMultiline`) Break before
#   inline ASM colon if the line length is longer than column limit.
# - `BBIAS_Always` (in configuration: `Always`) Always break before inline ASM
#   colon.
#
# (BreakBeforeInlineASMColonStyle)
BreakBeforeInlineASMColon: OnlyMultiline

# If true, ternary operators will be placed after line breaks.
#
# (boolean)
BreakBeforeTernaryOperators: true

# The break constructor initializers style to use.
#
# Possible values:
#
# - `BCIS_BeforeColon` (in configuration: `BeforeColon`) Break constructor
#   initializers before the colon and after the commas.
# - `BCIS_BeforeComma` (in configuration: `BeforeComma`) Break constructor
#   initializers before the colon and commas, and align the commas with the
#   colon.
# - `BCIS_AfterColon` (in configuration: `AfterColon`) Break constructor
#   initializers after the colon and commas.
#
# (BreakConstructorInitializersStyle)
BreakConstructorInitializers: BeforeColon

# The inheritance list style to use.
#
# Possible values:
#
# - `BILS_BeforeColon` (in configuration: `BeforeColon`) Break inheritance list
#   before the colon and after the commas.
# - `BILS_BeforeComma` (in configuration: `BeforeComma`) Break inheritance list
#   before the colon and commas, and align the commas with the colon.
# - `BILS_AfterColon` (in configuration: `AfterColon`) Break inheritance list
#   after the colon and commas.
# - `BILS_AfterComma` (in configuration: `AfterComma`) Break inheritance list
#   only after the commas.
#
# (BreakInheritanceListStyle)
BreakInheritanceList: BeforeColon

# Allow breaking string literals when formatting.
#
# (boolean)
BreakStringLiterals: true

# The column limit.
#
# A column limit of `0` means that there is no column limit. In this case,
# clang-format will respect the input’s line breaking decisions within
# statements unless they contradict other rules.
#
# (unsigned)
ColumnLimit: 80

# A regular expression that describes comments with special meaning, which
# should not be split into lines or otherwise changed.
#
# (string)
CommentPragmas: '^ IWYU pragma:'

# If `true`, consecutive namespace declarations will be on the same line. If
# `false`, each namespace is declared on a new line.
#
# If it does not fit on a single line, the overflowing namespaces get wrapped.
#
# (boolean)
CompactNamespaces: false

# The number of characters to use for indentation of constructor initializer
# lists as well as inheritance lists.
#
# (unsigned)
ConstructorInitializerIndentWidth: 4

# Indent width for line continuations.
#
# (unsigned)
ContinuationIndentWidth: 2

# If `true`, format braced lists as best suited for C++11 braced lists.
#
# Important differences:
#
# - No spaces inside the braced list.
# - No line break before the closing brace.
# - Indentation with the continuation indent, not with the block indent.
#
# Fundamentally, C++11 braced lists are formatted exactly like function calls
# would be formatted in their place. If the braced list follows a name (e.g. a
# type or variable name), clang-format formats as if the `{}` were the
# parentheses of a function call with that name. If there is no name, a
# zero-length name is assumed.
#
# (boolean)
Cpp11BracedListStyle: true

# If `true`, analyze the formatted file for the most common alignment of `&` and
# `*`. Pointer and reference alignment styles are going to be updated according
# to the preferences found in the file. `PointerAlignment` is then used only as
# fallback.
#
# (boolean)
DerivePointerAlignment: true

# Disables formatting completely.
#
# (boolean)
DisableFormat: false

# Defines when to put an empty line after access modifiers.
# `EmptyLineBeforeAccessModifier` configuration handles the number of empty
# lines between two access modifiers.
#
# Possible values:
#
# - `ELAAMS_Never` (in configuration: `Never`) Remove all empty lines after
#   access modifiers.
# - `ELAAMS_Leave` (in configuration: `Leave`) Keep existing empty lines after
#   access modifiers. MaxEmptyLinesToKeep is applied instead.
# - `ELAAMS_Always` (in configuration: `Always`) Always add empty line after
#   access modifiers if there are none. MaxEmptyLinesToKeep is applied also.
#
# (EmptyLineAfterAccessModifierStyle)
EmptyLineAfterAccessModifier: Never

# Defines in which cases to put empty line before access modifiers.
#
# Possible values:
#
# - `ELBAMS_Never` (in configuration: `Never`) Remove all empty lines before
#   access modifiers.
# - `ELBAMS_Leave` (in configuration: `Leave`) Keep existing empty lines before
#   access modifiers.
# - `ELBAMS_LogicalBlock` (in configuration: `LogicalBlock`) Add empty line only
#   when access modifier starts a new logical block. Logical block is a group of
#   one or more member fields or functions.
# - `ELBAMS_Always` (in configuration: `Always`) Always add empty line before
#   access modifiers unless access modifier is at the start of struct or class
#   definition.
#
# (EmptyLineBeforeAccessModifierStyle)
EmptyLineBeforeAccessModifier: LogicalBlock

# If `true`, clang-format detects whether function calls and definitions are
# formatted with one parameter per line.
#
# Each call can be bin-packed, one-per-line or inconclusive. If it is
# inconclusive, e.g. completely on one line, but a decision needs to be made,
# clang-format analyzes whether there are other bin-packed cases in the input
# file and act accordingly.
#
# NOTE: This is an experimental flag, that might go away or be renamed. Do not
#       use this in config files, etc. Use at your own risk.
#
# (boolean)
ExperimentalAutoDetectBinPacking: false

# If `true`, clang-format adds missing namespace end comments for namespaces and
# fixes invalid existing ones. This doesn’t affect short namespaces, which are
# controlled by `ShortNamespaceLines`.
#
# (boolean)
FixNamespaceComments: true

# A vector of macros that should be interpreted as foreach loops instead of as
# function calls.
#
# (list of strings)
ForEachMacros: [foreach, Q_FOREACH, BOOST_FOREACH]

# A vector of macros that should be interpreted as conditionals instead of as
# function calls.
#
# (list of string)
IfMacros: [KJ_IF_MAYBE]

# Dependent on the value, multiple `#include` blocks can be sorted as one and
# divided based on category.
#
# Possible values:
#
# - `IBS_Preserve` (in configuration: `Preserve`) Sort each `#include` block
#   separately.
# - `IBS_Merge` (in configuration: `Merge`) Merge multiple `#include` blocks
#   together and sort as one.
# - `IBS_Regroup` (in configuration: `Regroup`) Merge multiple `#include` blocks
#   together and sort as one. Then split into groups based on category priority.
#   See `IncludeCategories`.
#
# (IncludeBlocksStyle)
IncludeBlocks: Regroup

# Regular expressions denoting the different `#include` categories used for
# ordering `#includes`.
#
# POSIX extended regular expressions are supported.
#
# These regular expressions are matched against the filename of an include
# (including the <> or "") in order. The value belonging to the first matching
# regular expression is assigned and `#includes` are sorted first according to
# increasing category number and then alphabetically within each category.
#
# If none of the regular expressions match, INT\_MAX is assigned as category.
# The main header for a source file automatically gets category 0. so that it is
# generally kept at the beginning of the `#includes`
# (https://llvm.org/docs/CodingStandards.html#include-style). However, you can
# also assign negative priorities if you have certain headers that always need
# to be first.
#
# There is a third and optional field `SortPriority` which can used while
# `IncludeBlocks = IBS_Regroup` to define the priority in which `#includes`
# should be ordered. The value of `Priority` defines the order of
# `#include blocks` and also allows the grouping of `#includes` of different
# priority. `SortPriority` is set to the value of `Priority` as default if it
# is not assigned.
#
# Each regular expression can be marked as case sensitive with the field
# `CaseSensitive`, per default it is not.
#
# (List of IncludeCategories)
IncludeCategories:
  - Regex: ^<ext/.*\.h>
    Priority: 2
    SortPriority: 0
    CaseSensitive: false

  - Regex: ^<.*\.h>
    Priority: 1
    SortPriority: 0
    CaseSensitive: false

  - Regex: ^<.*
    Priority: 2
    SortPriority: 0
    CaseSensitive: false

  - Regex: .*
    Priority: 3
    SortPriority: 0
    CaseSensitive: false

# Specify a regular expression of suffixes that are allowed in the
# file-to-main-include mapping.
#
#  When guessing whether a  # include is the “main” include (to assign category
#  0, see above), use this regex of allowed suffixes to the header stem. A
#  partial match is done, so that:
#
# - "" means "arbitrary suffix"
# - "$" means "no suffix"
#
# For example, if configured to "(\_test)?$", then a header a.h would be seen as
# the “main” include in both a.cc and a\_test.cc.
#
# (string)
IncludeIsMainRegex: ([-_](test|unittest))?$

# Specify a regular expression for files being formatted that are allowed to be
# considered “main” in the file-to-main-include mapping.
#
# By default, clang-format considers files as “main” only when they end with:
# `.c`, `.cc`, `.cpp`, `.c++`, `.cxx`, `.m` or `.mm` extensions. For these files
# a guessing of “main” include takes place (to assign category 0, see above).
# This config option allows for additional suffixes and extensions for files to
# be considered as “main”.
#
# For example, if this option is configured to `(Impl\.hpp)$`, then a file
# `ClassImpl.hpp` is considered “main” (in addition to `Class.c`, `Class.cc`,
# `Class.cpp` and so on) and “main include file” logic will be executed (with
# _IncludeIsMainRegex_ setting also being respected in later phase). Without
# this option set, `ClassImpl.hpp` would not have the main include file put on
# top before any other include.
#
# (boolean)
IncludeIsMainSourceRegex: ''

# Specify whether access modifiers should have their own indentation level.
#
# When `false`, access modifiers are indented (or outdented) relative to the
# record members, respecting the `AccessModifierOffset`. Record members are
# indented one level below the record. When `true`, access modifiers get their
# own indentation level. As a consequence, record members are always indented 2
# levels below the record, regardless of the access modifier presence. Value of
# the `AccessModifierOffset` is ignored.
#
# (boolean)
IndentAccessModifiers: false

# Indent case label blocks one level from the case label.
#
# When `false`, the block following the case label uses the same indentation
# level as for the case label, treating the case label the same as an
# if-statement. When `true`, the block gets indented as a scope block.
#
# (boolean)
IndentCaseBlocks: false

# Indent case labels one level from the switch statement.
#
# When `false`, use the same indentation level as for the switch statement.
# Switch statement body is always indented one level more than case labels
# (except the first block following the case label, which itself indents the
# code - unless IndentCaseBlocks is enabled).
#
# (boolean)
IndentCaseLabels: true

# IndentExternBlockStyle is the type of indenting of extern blocks.
#
# Possible values:
#
# - `IEBS_AfterExternBlock` (in configuration: `AfterExternBlock`) Backwards
#   compatible with AfterExternBlock’s indenting.
# - `IEBS_NoIndent` (in configuration: `NoIndent`) Does not indent extern
#   blocks.
# - `IEBS_Indent` (in configuration: `Indent`) Indents extern blocks.
#
# (IndentExternBlockStyle)
IndentExternBlock: AfterExternBlock

# Indent goto labels.
#
# When false, goto labels are flushed left.
#
# (boolean)
IndentGotoLabels: true

# The preprocessor directive indenting style to use.
#
# Possible values:
#
# - `PPDIS_None` (in configuration: `None`) Does not indent any directives.
# - `PPDIS_AfterHash` (in configuration: `AfterHash`) Indents directives after
#   the hash.
# - `PPDIS_BeforeHash` (in configuration: `BeforeHash`) Indents directives
#   before the hash.
#
#
# (PPDirectiveIndentStyle)
IndentPPDirectives: None

# Indent the requires clause in a template. This only applies when
# `RequiresClausePosition` is `OwnLine`, or `WithFollowing`.
#
# In clang-format 12, 13 and 14 it was named `IndentRequires`.
#
# (boolean)
IndentRequiresClause: true

# The number of columns to use for indentation.
#
# (unsigned)
IndentWidth: 2

# Indent if a function definition or declaration is wrapped after the type.
#
# (boolean)
IndentWrappedFunctionNames: false

# Insert braces after control statements (`if`, `else`, `for`, `do`, and
# `while`) in C++ unless the control statements are inside macro definitions or
# the braces would enclose preprocessor directives.
#
# WARNING: Setting this option to `true` could lead to incorrect code formatting
#          due to clang-format’s lack of complete semantic information. As such,
#          extra care should be taken to review code changes made by this
#          option.
#
# (boolean)
InsertBraces: false

# Insert a newline at end of file if missing.
#
# (boolean)
InsertNewlineAtEOF: false

# If set to `TCS_Wrapped` will insert trailing commas in container literals
# (arrays and objects) that wrap across multiple lines. It is currently only
# available for JavaScript and disabled by default `TCS_None`.
# `InsertTrailingCommas` cannot be used together with `BinPackArguments` as
# inserting the comma disables bin-packing.
#
# Possible values:
#
# - `TCS_None` (in configuration: `None`) Do not insert trailing commas.
# - `TCS_Wrapped` (in configuration: `Wrapped`) Insert trailing commas in
#   container literals that were wrapped over multiple lines. Note that this is
#   conceptually incompatible with bin-packing, because the trailing comma is
#   used as an indicator that a container should be formatted one-per-line (i.e.
#   not bin-packed). So inserting a trailing comma counteracts bin-packing.
#
# (TrailingCommaStyle)
InsertTrailingCommas: None

# Format integer literal separators (`'` for C++ and `_` for C#, Java, and
# JavaScript).
#
# Nested configuration flags:
#
# Separator format of integer literals of different bases.
#
# If negative, remove separators. If `0`, leave the literal as is. If positive,
# insert separators between digits starting from the rightmost digit.
#
# For example, the config below will leave separators in binary literals alone,
# insert separators in decimal literals to separate the digits into groups of 3,
# and remove separators in hexadecimal literals.
#
# You can also specify a minimum number of digits (`BinaryMinDigits`,
# `DecimalMinDigits`, and `HexMinDigits`) the integer literal must have in order
# for the separators to be inserted.
#
# (IntegerLiteralSeparatorStyle)
IntegerLiteralSeparator:
  # Format separators in binary literals.
  #
  # (int8_t)
  Binary: 0

  # Format separators in binary literals with a minimum number of digits.
  #
  # (int8_t)
  BinaryMinDigits: 0

  # Format separators in decimal literals.
  #
  # (int8_t)
  Decimal: 0

  # Format separators in decimal literals with a minimum number of digits.
  #
  # (int8_t)
  DecimalMinDigits: 0

  # Format separators in hexadecimal literals.
  #
  # (int8_t)
  Hex: 0

  # Format separators in hexadecimal literals with a minimum number of digits.
  #
  # (int8_t)
  HexMinDigits: 0

# If true, the empty line at the start of blocks is kept.
#
# (boolean)
KeepEmptyLinesAtTheStartOfBlocks: false

# Keep empty lines (up to `MaxEmptyLinesToKeep`) at end of file.
#
# (boolean)
KeepEmptyLinesAtEOF: false

# The indentation style of lambda bodies. `Signature` (the default) causes the
# lambda body to be indented one additional level relative to the indentation
# level of the signature. `OuterScope` forces the lambda body to be indented one
# additional level relative to the parent scope containing the lambda signature.
#
# Possible values:
#
# - `LBI_Signature` (in configuration: `Signature`) Align lambda body relative
#   to the lambda signature. This is the default.
# - `LBI_OuterScope` (in configuration: `OuterScope`) For statements within
#   block scope, align lambda body relative to the indentation level of the
#   outer scope the lambda signature resides in.
#
# (LambdaBodyIndentationKind)
LambdaBodyIndentation: Signature

# Line ending style (`\n` or `\r\n`) to use.
#
# Possible values:
#
# - `LE_LF` (in configuration: `LF`) Use `\n`.
# - `LE_CRLF` (in configuration: `CRLF`) Use `\r\n`.
# - `LE_DeriveLF` (in configuration: `DeriveLF`) Use `\n` unless the input has
#   more lines ending in `\r\n`.
# - `LE_DeriveCRLF` (in configuration: `DeriveCRLF`) Use `\r\n` unless the input
#   has more lines ending in `\n`.
#
# (LineEndingStyle)
LineEnding: DeriveLF

# A regular expression matching macros that start a block.
#
# (string)
MacroBlockBegin: ''

# A regular expression matching macros that end a block.
#
# (string)
MacroBlockEnd: ''

# A regular expression matching macros that end a block.
#
# (unsigned)
MaxEmptyLinesToKeep: 1

# The indentation used for namespaces.
#
# Possible values:
#
# - `NI_None` (in configuration: `None`) Don’t indent in namespaces.
# - `NI_Inner` (in configuration: `Inner`) Indent only in inner namespaces
#   nested in other namespaces).
# - `NI_All` (in configuration: `All`) Indent in all namespaces.
#
# (NamespaceIndentationKind)
NamespaceIndentation: None

# The pack constructor initializers style to use.
#
# Possible values:
#
# - `PCIS_Never` (in configuration: `Never`) Always put each constructor
#   initializer on its own line.
# - `PCIS_BinPack` (in configuration: `BinPack`) Bin-pack constructor
#   initializers.
# - `PCIS_CurrentLine` (in configuration: `CurrentLine`) Put all constructor
#   initializers on the current line if they fit. Otherwise, put each one on
#   its own line.
# - `PCIS_NextLine` (in configuration: `NextLine`) Same as `PCIS_CurrentLine`
#   except that if all constructor initializers do not fit on the current line,
#   try to fit them on the next line.
# - `PCIS_NextLineOnly` (in configuration: `NextLineOnly`) Put all constructor
#   initializers on the next line if they fit. Otherwise, put each one on its
#   own line.
#
# (PackConstructorInitializersStyle)
PackConstructorInitializers: NextLine

# The penalty for breaking around an assignment operator.
#
# (unsigned)
PenaltyBreakAssignment: 2

# The penalty for breaking a function call after call(.
#
# (unsigned)
PenaltyBreakBeforeFirstCallParameter: 1

# The penalty for each line break introduced inside a comment.
#
# (unsigned)
PenaltyBreakComment: 300

# The penalty for breaking before the first <<.
#
# (unsigned)
PenaltyBreakFirstLessLess: 120

# The penalty for breaking after (.
#
# (unsigned)
PenaltyBreakOpenParenthesis: 0

# The penalty for each line break introduced inside a string literal.
#
# (unsigned)
PenaltyBreakString: 1000

# The penalty for breaking after template declaration.
#
# (unsigned)
PenaltyBreakTemplateDeclaration: 10

# The penalty for each character outside of the column limit.
#
# (unsigned)
PenaltyExcessCharacter: 1000000

# Penalty for each character of whitespace indentation (counted relative to
# leading non-whitespace column).
#
# (unsigned)
PenaltyIndentedWhitespace: 0

# Penalty for putting the return type of a function onto its own line.
#
# (unsigned)
PenaltyReturnTypeOnItsOwnLine: 200

# Pointer and reference alignment style.
#
# Possible values:
#
# - `PAS_Left` (in configuration: `Left`) Align pointer to the left.
# - `PAS_Right` (in configuration: `Right`) Align pointer to the right.
# - `PAS_Middle` (in configuration: `Middle`) Align pointer in the middle.
#
# (PointerAlignmentStyle)
PointerAlignment: Left

# The number of columns to use for indentation of preprocessor statements. When
# set to -1 (default) IndentWidth is used also for preprocessor statements.
#
# (integer)
PPIndentWidth: -1

# Different ways to arrange specifiers and qualifiers (e.g. const/volatile).
#
# WARNING: Setting `QualifierAlignment` to something other than `Leave`, COULD
#          lead to incorrect code formatting due to incorrect decisions made due
#          to clang-formats lack of complete semantic information. As such extra
#          care should be taken to review code changes made by the use of this
#          option.
#
# Possible values:
#
# - `QAS_Leave` (in configuration: `Leave`) Don’t change specifiers/qualifiers
#   to either Left or Right alignment (default).
# - `QAS_Left` (in configuration: `Left`) Change specifiers/qualifiers to be
#   left-aligned.
# - `QAS_Right` (in configuration: `Right`) Change specifiers/qualifiers to be
#   right-aligned.
# - `QAS_Custom` (in configuration: `Custom`) Change specifiers/qualifiers to be
#   aligned based on `QualifierOrder`. With:
#
# (QualifierAlignmentStyle)
QualifierAlignment: Left

# Defines hints for detecting supported languages code blocks in raw strings.
#
# A raw string with a matching delimiter or a matching enclosing function name
# will be reformatted assuming the specified language based on the style for
# that language defined in the .clang-format file. If no style has been defined
# in the .clang-format file for the specific language, a predefined style given
# by ‘BasedOnStyle’ is used. If ‘BasedOnStyle’ is not found, the formatting is
# based on llvm style. A matching delimiter takes precedence over a matching
# enclosing function name for determining the language of the raw string
# contents.
#
# If a canonical delimiter is specified, occurrences of other delimiters for the
# same language will be updated to the canonical if possible.
#
# There should be at most one specification per language and each delimiter and
# enclosing function should not occur in multiple specifications.
#
# (List of RawStringFormats)
RawStringFormats:
  - Language: Cpp
    Delimiters: [cc, CC, cpp, Cpp, CPP, c++, C++]
    CanonicalDelimiter: ''
    BasedOnStyle: google
  - Language: TextProto
    Delimiters: [pb, PB, proto, PROTO]
    EnclosingFunctions:
      - EqualsProto
      - EquivToProto
      - PARSE_PARTIAL_TEXT_PROTO
      - PARSE_TEST_PROTO
      - PARSE_TEXT_PROTO
      - ParseTextOrDie
      - ParseTextProtoOrDie
      - ParseTestProto
      - ParsePartialTestProto
    CanonicalDelimiter: pb
    BasedOnStyle: google

# Reference alignment style (overrides `PointerAlignment` for references).
#
# Possible values:
#
# - `RAS_Pointer` (in configuration: `Pointer`) Align reference like
#   `PointerAlignment`.
# - `RAS_Left` (in configuration: `Left`) Align reference to the left.
# - `RAS_Right` (in configuration: `Right`) Align reference to the right.
# - `RAS_Middle` (in configuration: `Middle`) Align reference in the middle.
#
# (ReferenceAlignmentStyle)
ReferenceAlignment: Pointer

# If `true`, clang-format will attempt to re-flow comments. That is it will
# touch a comment and _reflow_ long comments into new lines, trying to obey the
# `ColumnLimit`.
#
# (boolean)
ReflowComments: true

# Remove optional braces of control statements (`if`, `else`, `for`, and
# `while`) in C++ according to the LLVM coding style.
#
# WARNING: This option will be renamed and expanded to support other styles.
#
# WARNING: Setting this option to `true` could lead to incorrect code formatting
#          due to clang-format’s lack of complete semantic information. As such,
#          extra care should be taken to review code changes made by this
#          option.
#
# (boolean)
RemoveBracesLLVM: false

# Remove redundant parentheses.
#
# WARNING: Setting this option to any value other than `Leave` could lead to
#          incorrect code formatting due to clang-format’s lack of complete
#          semantic information. As such, extra care should be taken to review
#          code changes made by this option.
#
# Possible values:
#
# - `RPS_Leave` (in configuration: `Leave`) Do not remove parentheses.
# - `RPS_MultipleParentheses` (in configuration: `MultipleParentheses`) Replace
#   multiple parentheses with single parentheses.
# - `RPS_ReturnStatement` (in configuration: `ReturnStatement`) Also remove
#   parentheses enclosing the expression in a `return`/`co_return` statement.
#
# (RemoveParenthesesStyle)
RemoveParentheses: Leave

# Remove semicolons after the closing brace of a non-empty function.
#
# WARNING: Setting this option to `true` could lead to incorrect code formatting
#          due to clang-format’s lack of complete semantic information. As such,
#          extra care should be taken to review code changes made by this
#          option.
#
# (boolean)
RemoveSemicolon: false

# The position of the `requires` clause.
#
# Possible values:
#
# - `RCPS_OwnLine` (in configuration: `OwnLine`) Always put the `requires`
#   clause on its own line.
# - `RCPS_WithPreceding` (in configuration: `WithPreceding`) Try to put the
#   clause together with the preceding part of a declaration. For class
#   templates: stick to the template declaration. For function templates: stick
#   to the template declaration. For function declaration followed by a requires
#   clause: stick to the parameter list.
# - `RCPS_WithFollowing` (in configuration: `WithFollowing`) Try to put the
#   `requires` clause together with the class or function declaration.
# - `RCPS_SingleLine` (in configuration: `SingleLine`) Try to put everything in
#   the same line if possible. Otherwise normal line breaking rules take over.
#
# (RequiresClausePositionStyle)
RequiresClausePosition: OwnLine

# The indentation used for requires expression bodies.
#
# Possible values:
#
# - `REI_OuterScope` (in configuration: `OuterScope`) Align requires expression
#   body relative to the indentation level of the outer scope the requires
#   expression resides in. This is the default.
# - `REI_Keyword` (in configuration: `Keyword`) Align requires expression body
#   relative to the `requires` keyword.
#
# (RequiresExpressionIndentationKind)
RequiresExpressionIndentation: OuterScope

# Specifies the use of empty lines to separate definition blocks, including
# classes, structs, enums, and functions.
#
# Possible values:
#
# - `SDS_Leave` (in configuration: `Leave`) Leave definition blocks as they are.
# - `SDS_Always` (in configuration: `Always`) Insert an empty line between
#   definition blocks.
# - `SDS_Never` (in configuration: `Never`) Remove any empty line between
#   definition blocks.
#
# (SeparateDefinitionStyle)
SeparateDefinitionBlocks: Leave

# The maximal number of unwrapped lines that a short namespace spans. Defaults
# to 1.
#
# This determines the maximum length of short namespaces by counting unwrapped
# lines (i.e. containing neither opening nor closing namespace brace) and makes
# "FixNamespaceComments" omit adding end comments for those.
#
# (unsigned)
ShortNamespaceLines: 1

# Controls if and how clang-format will sort `#includes`.
#
# Possible values:
#
# - `SI_Never` (in configuration: `Never`) Includes are never sorted.
# - `SI_CaseSensitive` (in configuration: `CaseSensitive`) Includes are sorted
#   in an ASCIIbetical or case sensitive fashion.
# - `SI_CaseInsensitive` (in configuration: `CaseInsensitive`) Includes are
#   sorted in an alphabetical or case insensitive fashion.
#
# (SortIncludesOptions)
SortIncludes: CaseSensitive

# Controls if and how clang-format will sort using declarations.
#
# Possible values:
#
# - `SUD_Never` (in configuration: `Never`) Using declarations are never sorted.
# - `SUD_Lexicographic` (in configuration: `Lexicographic`) Using declarations
#   are sorted in the order defined as follows: Split the strings by "::" and
#   discard any initial empty strings. Sort the lists of names
#   lexicographically, and within those groups, names are in case-insensitive
#   lexicographic order.
#
# - `SUD_LexicographicNumeric` (in configuration: `LexicographicNumeric`) Using
#   declarations are sorted in the order defined as follows: Split the strings
#   by "::" and discard any initial empty strings. The last element of each list
#   is a non-namespace name; all others are namespace names. Sort the lists of
#   names lexicographically, where the sort order of individual names is that
#   all non-namespace names come before all namespace names, and within those
#   groups, names are in case-insensitive lexicographic order.
#
# (SortUsingDeclarationsOptions)
SortUsingDeclarations: LexicographicNumeric

# If `true`, a space is inserted after C style casts.
#
# (boolean)
SpaceAfterCStyleCast: false

# If `true`, a space is inserted after the logical not operator (`!`).
#
# (boolean)
SpaceAfterLogicalNot: false

# If `true`, a space will be inserted after the ‘template’ keyword.
#
# (boolean)
SpaceAfterTemplateKeyword: true

# Defines in which cases to put a space before or after pointer qualifiers
#
# Possible values:
#
# - `SAPQ_Default` (in configuration: `Default`) Don’t ensure spaces around
#   pointer qualifiers and use PointerAlignment instead.
# - `SAPQ_Before` (in configuration: `Before`) Ensure that there is a space
#   before pointer qualifiers.
#
# - `SAPQ_After` (in configuration: `After`) Ensure that there is a space after
#   pointer qualifiers.
#
# - `SAPQ_Both` (in configuration: `Both`) Ensure that there is a space both
#   before and after pointer qualifiers.
#
# (SpaceAroundPointerQualifiersStyle)
SpaceAroundPointerQualifiers: Default

# If `false`, spaces will be removed before assignment operators.
#
# (boolean)
SpaceBeforeAssignmentOperators: true

# If `false`, spaces will be removed before case colon.
#
# (boolean)
SpaceBeforeCaseColon: false

# If `true`, a space will be inserted before a C++11 braced list used to
# initialize an object (after the preceding identifier or type).
#
# (boolean)
SpaceBeforeCpp11BracedList: false

# If `true`, a space will be inserted before a C++11 braced list used to
# initialize an object (after the preceding identifier or type).
#
# (boolean)
SpaceBeforeCtorInitializerColon: true

# If `false`, spaces will be removed before inheritance colon.
#
# (boolean)
SpaceBeforeInheritanceColon: true

# If `true`, a space will be added before a JSON colon. For other languages,
# e.g. JavaScript, use `SpacesInContainerLiterals` instead.
#
# (boolean)
SpaceBeforeJsonColon: false

# Defines in which cases to put a space before opening parentheses.
#
# Possible values:
#
# - `SBPO_Never` (in configuration: `Never`) Never put a space before opening
#   parentheses.
# - `SBPO_ControlStatements` (in configuration: `ControlStatements`) Put a space
#   before opening parentheses only after control statement keywords
#   (`for/if/while...`).
# - `SBPO_ControlStatementsExceptControlMacros` (in configuration:
#   `ControlStatementsExceptControlMacros`) Same as `SBPO_ControlStatements`
#   except this option doesn’t apply to ForEach and If macros. This is useful in
#   projects where ForEach/If macros are treated as function calls instead of
#   control statements. `SBPO_ControlStatementsExceptForEachMacros` remains an
#   alias for backward compatibility.
# - `SBPO_NonEmptyParentheses` (in configuration: `NonEmptyParentheses`) Put a
#   space before opening parentheses only if the parentheses are not empty i.e.
#   '()'
# - `SBPO_Always` (in configuration: `Always`) Always put a space before opening
#   parentheses, except when it’s prohibited by the syntax rules (in
#   function-like macro definitions) or when determined by other style rules
#   (after unary operators, opening parentheses, etc.)
# - `SBPO_Custom` (in configuration: `Custom`) Configure each individual space
#   before parentheses in `SpaceBeforeParensOptions`.
#
# (SpaceBeforeParensStyle)
SpaceBeforeParens: ControlStatements

# Control of individual space before parentheses.
#
# If `SpaceBeforeParens` is set to `Custom`, use this to specify how each
# individual space before parentheses case should be handled. Otherwise, this is
# ignored.
#
#
# (SpaceBeforeParensCustom)
SpaceBeforeParensOptions:
  # If `true`, put space between control statement keywords (for/if/while…) and
  # opening parentheses.
  #
  # (boolean)
  AfterControlStatements: true

  # If `true`, put space between foreach macros and opening parentheses.
  #
  # (boolean)
  AfterForeachMacros: true

  # If `true`, put space between foreach macros and opening parentheses.
  #
  # (boolean)
  AfterFunctionDefinitionName: false

  # If `true`, put space between foreach macros and opening parentheses.
  #
  # (boolean)
  AfterFunctionDeclarationName: false

  # If `true`, put space between if macros and opening parentheses.
  #
  # (boolean)
  AfterIfMacros: true

  # If `true`, put space between if macros and opening parentheses.
  #
  # (boolean)
  AfterOverloadedOperator: false

  # If `true`, put space between requires keyword in a requires clause and
  # opening parentheses, if there is one.
  #
  # (boolean)
  AfterRequiresInClause: false

  # If `true`, put space between requires keyword in a requires expression and
  # opening parentheses.
  #
  # (boolean)
  AfterRequiresInExpression: false

  # If `true`, put a space before opening parentheses only if the parentheses
  # are not empty.
  #
  # (boolean)
  BeforeNonEmptyParentheses: false

# If `false`, spaces will be removed before range-based for loop colon.
#
# (boolean)
SpaceBeforeRangeBasedForLoopColon: true

# If `true`, spaces will be before `[`. Lambdas will not be affected. Only the
# first `[` will get a space added.
#
# (boolean)
SpaceBeforeSquareBrackets: false

# If `true`, spaces will be inserted into `{}`.
#
# (boolean)
SpaceInEmptyBlock: false

# The number of spaces before trailing line comments (`//` - comments).
#
# This does not affect trailing block comments (`/*` - comments) as those
# commonly have different usage patterns and a number of special cases. In the
# case of Verilog, it doesn’t affect a comment right after the opening
# parenthesis in the port or parameter list in a module header, because it is
# probably for the port on the following line instead of the parenthesis it
# follows.
#
# (unsigned)
SpacesBeforeTrailingComments: 2

# The SpacesInAnglesStyle to use for template argument lists.
#
# Possible values:
#
# - `SIAS_Never` (in configuration: `Never`) Remove spaces after `<` and before
#   `>`.
# - `SIAS_Always` (in configuration: `Always`) Add spaces after `<` and before
#   `>`.
# - `SIAS_Leave` (in configuration: `Leave`) Keep a single space after `<` and
#   before `>` if any spaces were present. Option `Standard: Cpp03` takes
#   precedence.
#
# (SpacesInAnglesStyle)
SpacesInAngles: Never

# If `true`, spaces are inserted inside container literals (e.g. ObjC and
# Javascript array and dict literals). For JSON, use `SpaceBeforeJsonColon`
# instead.
#
# (boolean)
SpacesInContainerLiterals: true

# How many spaces are allowed at the start of a line comment. To disable the
# maximum set it to `-1`, apart from that the maximum takes precedence over the
# minimum.
#
# Note that in line comment sections the relative indent of the subsequent lines
# is kept.
#
# This option has only effect if `ReflowComments` is set to `true`.
#
#
# (SpacesInLineComment)
SpacesInLineCommentPrefix:
  # The minimum number of spaces at the start of the comment.
  #
  # (unsigned)
  Minimum: 1

  # The maximum number of spaces at the start of the comment.
  #
  # (unsigned)
  Maximum: -1

# Defines in which cases spaces will be inserted after `(` and before `)`.
#
# Possible values:
#
# - `SIPO_Never` (in configuration: `Never`) Never put a space in parentheses.
# - `SIPO_Custom` (in configuration: `Custom`) Configure each individual space
#   in parentheses in SpacesInParensOptions.
#
# (SpacesInParensStyle)
SpacesInParens: Never

# Control of individual spaces in parentheses.
#
# If `SpacesInParens` is set to `Custom`, use this to specify how each
# individual space in parentheses case should be handled. Otherwise, this is
# ignored.
#
# (SpacesInParensCustom)
SpacesInParensOptions:
  # Put a space in C style casts.
  #
  # (boolean)
  InCStyleCasts: false

  # Put a space in parentheses only inside conditional statements
  # (`for/if/while/switch...`).
  #
  # (boolean)
  InConditionalStatements: false

  # Put a space in parentheses only if the parentheses are empty i.e. '()'
  #
  # (boolean)
  InEmptyParentheses: false

  # Put a space in parentheses not covered by preceding options.
  #
  # (boolean)
  Other: false

# If `true`, spaces will be inserted after `[` and before `]`. Lambdas without
# arguments or unspecified size array declarations will not be affected.
#
# (boolean)
SpacesInSquareBrackets: false

# Parse and format C++ constructs compatible with this standard.
#
# Possible values:
#
# - `LS_Cpp03` (in configuration: `c++03`) Parse and format as C++03. `Cpp03` is
#   a deprecated alias for `c++03`
# - `LS_Cpp11` (in configuration: `c++11`) Parse and format as C++11.
# - `LS_Cpp14` (in configuration: `c++14`) Parse and format as C++14.
# - `LS_Cpp17` (in configuration: `c++17`) Parse and format as C++17.
# - `LS_Cpp20` (in configuration: `c++20`) Parse and format as C++20.
# - `LS_Latest` (in configuration: `Latest`) Parse and format using the latest
#   supported language version. `Cpp11` is a deprecated alias for `Latest`
# - `LS_Auto` (in configuration: `Auto`) Automatic detection based on the input.
#
# (LanguageStandard)
Standard: Auto

# Macros which are ignored in front of a statement, as if they were an
# attribute. So that they are not parsed as identifier, for example for Qts
# emit.
#
# (list of strings)
StatementAttributeLikeMacros: [Q_EMIT]

# A vector of macros that should be interpreted as complete statements.
#
# Typical macros are expressions, and require a semi-colon to be added;
# sometimes this is not the case, and this allows to make clang-format aware of
# such cases.
#
# For example: Q_UNUSED
#
# (list of strings)
StatementMacros: [Q_UNUSED, QT_REQUIRE_VERSION]

# The number of columns used for tab stops.
#
# (unsigned)
TabWidth: 8

# The way to use tab characters in the resulting file.
#
# Possible values:
#
# - `UT_Never` (in configuration: `Never`) Never use tab.
# - `UT_ForIndentation` (in configuration: `ForIndentation`) Use tabs only for
#   indentation.
# - `UT_ForContinuationAndIndentation` (in configuration:
#   `ForContinuationAndIndentation`) Fill all leading whitespace with tabs, and
#   use spaces for alignment that appears within a line (e.g. consecutive
#   assignments and declarations).
# - `UT_AlignWithSpaces` (in configuration: `AlignWithSpaces`) Use tabs for line
#   continuation and indentation, and spaces for alignment.
# - `UT_Always` (in configuration: `Always`) Use tabs whenever we need to fill
#   whitespace that spans at least from one tab stop to the next one.
#
# (UseTabStyle)
UseTab: Never

# For Verilog, put each port on its own line in module instantiations.
#
# (boolean)
VerilogBreakBetweenInstancePorts: true

# A vector of macros which are whitespace-sensitive and should not be touched.
#
#
# (list of strings)
WhitespaceSensitiveMacros:
  - BOOST_PP_STRINGIZE
  - CF_SWIFT_NAME
  - NS_SWIFT_NAME
  - PP_STRINGIZE
  - STRINGIZE
